<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="From to Earth - 小事成就大事,细节成就完美"><title>浅谈显 ipqq 发展历程 附显 ipqq原理 | From to Earth</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script src="https://www.googletagmanager.com/gtag/js?id=UA-14722977-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-14722977-1');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浅谈显 ipqq 发展历程 附显 ipqq原理</h1><a id="logo" href="/.">From to Earth</a><p class="description">小事成就大事,细节成就完美</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浅谈显 ipqq 发展历程 附显 ipqq原理</h1><div class="post-meta">2007-10-08<span> | </span><span class="category"><a href="/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/">软件技术</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 10.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 41</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>声明，本文章未经过疯狂绅士与runjin的同意不得转载。<br />为了珊蝴虫QQ精神能永远流传，本人未经过疯狂绅士与runjin的同意，作为技术文章收集，移做永久收藏<br /><br />浅谈IPQQ软件的技术发展轨迹<br /><br />疯狂绅士、RunJin<br /><br />摘要：本文先给出了IPQQ的界定，并介绍了不同历史时期具有里程碑意义的IPQQ。根据几个具有里程碑意义的IPQQ，作者简要的分析了其技术特点，并以此阐述IPQQ软件的发展轨迹。<br /><br />关键字:&nbsp;&nbsp; IPQQ、破解、木子QQ、外挂、珊瑚虫外挂<br /><br />一、IPQQ历史回顾<br />QQ作为国内用户量最大的IM，专门针对其发布一些附加功能是一个古老的话题。在QQ的弹出窗口上显示发消息用户IP的变种QQ成为大家最常用的工具,这种工具我们称为IPQQ。<br />1999年，IPQQ的始祖出现了，是在QQ的前身OICQ时候出现的。邹丹制作的破解版，可以说形式上开创了一个时代。尽管时间过去了好几年，邹丹创立的模式几乎成为了一种标准——密界的标准，以后所有QQ显IP的方式都是继承邹丹显示IP的方式。<br />邹丹的这一举动，在当时引起了一大片争议声。邹丹也收到了腾讯的律师函，邹丹考虑再三后，退出了为制作IPQQ的行列。 <br />接下来又有好多个勇士站了出来，其中最有名的是木子。木子的软件非常流行，与邹丹的软件相比，它的框架更好，更稳定，同时支持不同版本的QQ。木子的这个框架影响了大量的刚出道的Cracker，包括本文的作者之一 ——RunJin，其发布的飘云版QQ在一段时期里面被人骂成了剽窃。期间有很多显IP的QQ，说白了都是参考木子的，其中绝大部分根本就是木子的版本，不过是改了几个字或很取巧的换上自己的标签而已。<br />珊瑚虫前身的出现又是一个里程碑，这东西由Cygwin捣腾出来的。先揭一下Cygwin的老底，此人与疯狂绅士同是水木清华黑客版版主。<br />珊瑚虫QQ外挂的原型是Cygwin大概用了两天写出来的。这东西的出现让腾讯大为挠头，因为这个软件本身并没有修改QQ的任何程序。它是一个单存的外挂形式，因此避免了相关的法律问题。要说明的是珊瑚虫的历史比木子更早。可以说，珊瑚虫就是紧接着邹丹的版本出现的。这个时期的珊瑚虫完全由soff制作，不过这个时候的珊瑚虫不是外挂形式，同时质量非常高，与一年后出现的木子版相比也毫不逊色。这也是后来Quaful和cygwin找到soff合作的原因。这个时期的珊瑚虫版本因为收到了腾讯的律师信而被迫中止，所以给了后来木子兴起的机会。<br />由于珊瑚虫外挂不涉及到版权问题，并且其性能优越，导致了珊瑚虫外挂的下载量急剧的增大，从一些网站的分析来看，它甚至超过了QQ本身的下载量。珊瑚虫的成功在于它不断的推出新版本，作者大致统计了一下，从珊瑚虫0.1版到现在的4.0beta版，珊瑚虫一共推出了61个版本（不包括4.0以下的测试版）。正是由于珊瑚虫不懈的努力，使得珊瑚虫外挂声名远扬。<br />也许是精力的问题，当珊瑚虫的第二任作者soff觉得天天追赶着QQ的新版本而被迫推出一个个新版本觉得实在是很无趣的时候，内心深处对珊瑚虫来一个大变化已经变得很迫切。在外挂思维以及GAIM与Luma QQ等思想的指引下，Soff考虑一种新的方式，这个方式的执行者是Qulful，Qulful卖命的写出了珊瑚虫QQ4.0。<br />珊瑚虫QQ4.0又是一个里程碑，简单的说，以前的版本只要耐心去检查QQ的内存，总能找到IP地址的入口。因此可以说在珊瑚虫4.0之前的显IP的版本大都是一个简单的Cracker过程，只要能看懂段刚（看雪）《加密与解密》一书，折腾出某个IPQQ不是一见很难的事情。就是做一个外挂形式的IPQQ也并非难事。而珊瑚虫4.0可以说从根本上解决这个问题，它直接截获的是QQ的网络包，从网络包中获取其IP地址的。<br />从上面的简单的回顾，我们可以看出IPQQ的几个里程碑。<br />1、邹丹，IPQQ的开山鼻祖，IPQQ形式的确立。<br />2、木子，IPQQ的中兴，确立其成为修改QQ函数的地址方式的IPQQ的霸主地位。<br />3、Cygwin，IPQQ的转折，以外挂的形式击败了修改函数地址方式，成为了近两年来事实上IPQQ的霸主。<br />4、Quaful，思路的拓展，IPQQ也许只是珊瑚虫外挂的一个简单运用而已。<br /><br />上述四个里程碑中，由于邹丹的版本太久远，这里不作讨论，本文仅就后3个里程碑简单的来分析一下其技术思路，尤其是后两种。<br /><br />二、木子显IPQQ版本原理简介<br />与所有的破解软件一样，都有一个原则——点穴。木子与其它所有的IPQQ一样，都是很偷懒的，都是试图只通过修改几个字节，就达到想要的效果。<br />对于IPQQ来说，能利用QQ原来的功能就利用原来的功能。这似乎是一条铁律。<br />木子IPQQ，在网上已经可以下载到它的代码。这里只讲解木子IPQQ的部分代码。<br />SetIP proc<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushad<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;取得IP地址&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp; eax,dword ptr [ebp-10h]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp; offset dwIp<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp; offset szRecentip<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp; eax<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp; ecx, [eax]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp; dword ptr [ecx+34h]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;取得端口号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;;<br />……<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;取得版本号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;;<br />……<br />not2003:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />下面我们再看飘云的IPQQ的代码。<br />pushad<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;取得IP地址&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp; eax,dword ptr [ebp-14h]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp; offset dwIp<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp; offset szRecentip<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp; eax<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp; ecx,[eax]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp; dword ptr [ecx+34h]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp&nbsp;&nbsp; dwIp,0 ;是否已经取得IP<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……<br />上面给出了两个不同IPQQ的如何获得IP地址部分的，这两段代码是针对不同版本的QQ。黑体字表示上述的不同地方。<br />由此我们可以看到，要制作IPQQ核心是找到显示IP的那个函数的入口。这个函数的查找是个关键。而木子的出现其意义在于他给出了一个框架。因此很多后续的IPQQ就更偷懒，他们只是参考木子的版本，在取IP的原理上只要改动一点就可以了。<br />木子制作的IPQQ可以说是能利用QQ的功能就尽量利用QQ的功能。而很多后来者制作的IPQQ其原则是，能利用木子就尽量利用木子。上述给出的飘云的IPQQ代码就是一个例子。<br /><br />三、珊瑚虫4.0以下版本原理。<br />“珊瑚虫最初版很简单的，也参考了之前别人修改的方法，比如版本库就是直接盗用木子的，不过这个版本库盗用不是技术盗用，不被人介意的。”这段话是珊瑚虫的作者Cygwin所说的。<br />珊瑚虫外挂版本与木子版本比起来最大的不同在于——其利用了钩子的技术,不知道其是否用到了win2k的SDK包，否则这段代码都可以直接参考。是在QQ运行的时候获得了其IP地址的。而不是象木子一样直接给出一个显IP的破解版本。然而,在取得IP的原理上,珊瑚虫和木子是基本相同和飘云的更是非常相象。<br />下面是珊瑚虫3.16的取IP部分反汇编代码：<br />mov eax,dword ptr ss:[esp+10]<br />lea ecx,dword ptr ss:[esp+1C]<br />push ecx<br />push DUMPED.01B8D9EC&nbsp;&nbsp;&nbsp;&nbsp; ; ASCII对应的字符为”dwRecentIP”<br />mov edx,dword ptr ds:[eax]<br />push eax<br />call dword ptr ds:[edx+34]<br />………………………………………..<br />mov eax,dword ptr ss:[esp+10]<br />lea ecx,dword ptr ss:[esp+1C]<br />push ecx<br />push DUMPED.01B8D9D8&nbsp;&nbsp;&nbsp;&nbsp; ; ASCII对应的字符为”dwC2CIP”<br />mov edx,dword ptr ds:[eax]<br />push eax<br />call dword ptr ds:[edx+34]<br />…………………………………..<br />mov eax,dword ptr ss:[esp+10]<br />lea ecx,dword ptr ss:[esp+1C]<br />push ecx<br />push DUMPED.01B8D9C8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ASCII对应的字符为 “dwIP”<br />mov edx,dword ptr ds:[eax]<br />push eax<br />call dword ptr ds:[edx+34]<br /><br />虽然寄存器的具体使用不同,但动态调试的时候就会发现,其调用的函数和飘云的是一样的。<br />珊瑚虫的原理可以用下面的话简要来表达。<br />1、&nbsp;&nbsp;&nbsp;&nbsp; 绕开原来的流程<br />2、&nbsp;&nbsp;&nbsp;&nbsp; 获取IP<br />3、&nbsp;&nbsp;&nbsp;&nbsp; 把自己的窗体挂上QQ的窗体<br />4、&nbsp;&nbsp;&nbsp;&nbsp; 把获取的IP显示在自己的窗体上<br />RunJin用softice 、OllyDbg在: win 2000 sp4 , win 98操作系统对 QQ2005贺岁版珊瑚虫外挂进行了分析。<br />由于win nt 平台和win9x 的差异,珊瑚虫外挂因系统的不同而分开两种工作原理。珊瑚外挂是给QQ的主程序QQ.exe外挂了一个Coralqq.dll,而完成这个工作的就是coralqq.exe .要加载一个dll文件必须是qq.exe。<br />在win2000&#x2F;xp下coralqq.exe先创建QQ的进程,同时也就创建了QQ的暂停的主线程,接着往QQ进程的内存写入代码,修改Ntdll.NtTestAlert的代码让程序跳到附加代码处执行,在执行的过程中恢复Ntdll.NtTestAlert处被改了的代码,同时加载Coralqq.dll。<br />在win9x下,coralqq.exe先创建QQ的进程,同时也就创建了QQ的暂停的主线程,接着在QQ.exe的内存写数据,改写QQ.exe的oep从而达到改变程序流程的目的,让其先执行附加代码,加载Coralqq.dll，加载完后再跳到原来的QQ.exe的oep的下一条指令继续执行。详见RunJin的&lt;&lt;珊瑚虫外挂原理分析&gt;&gt;一文。<br />从RunJin的分析可以看出，珊瑚虫外挂想得很周到的，它绕开原来QQ的流程也是非常巧妙。当然如何高效的利用钩子大家可以去看相关的文章，这里不再详述。<br />可以这么说，珊瑚虫最大的特色是，用C++代替原来木子的部分代码。而这段代码的前面部分又是那么的巧妙的绕开了原来QQ的流程。<br />正如木子版本一样，越来越多的人利用上了一个原则——能用珊瑚虫的功能就尽量利用珊瑚虫的功能。<br />QQ狂人DIY版是把珊瑚虫外挂注入到QQ.exe里面，以实现直接点QQ.exe就可以直接启动珊瑚虫外挂的目的。<br />这类把外挂形式又变成了非外挂形式。它们所用的工具:LordPE，详细的教程在网上有下载。最终出来的IPQQ部分机器可能不兼容，但是大部分是可以的。<br /><br />四、珊瑚虫4.0 IPQQ原理简介<br />珊瑚虫4.0可以说是IPQQ有史以来一个最重大的突破。在介绍这个版本必须提到KQL库（Kwafu QQ Library）。<br />KQL是怎么出来的呢？全是LumaQQ给逼的。那个如来神掌的影响力实在太大了，人人都问珊瑚虫：“珊瑚虫为什么不做如来神掌啊？”当然在3.x的架构下是不可能的事情。后来Quaful就说，干脆把LumaQQ移植过来，这样就能实现了。后来Quaful用了2个月的时间完成了这个工作。Kwafu是Quaful的一个马甲的名字，所以叫做Kwafu QQ Library。至于说KQL带来的QQ版本无关的其他好处，都是附带的好处了。<br />Windows平台下的KQL库重点是最大限度的保持和官方QQ客户端的兼容性，所以，KQL库是做为一个“外挂”来开发，它的表面功能全都还是依附于官方QQ客户端来实现的。对于用户来说，就是不会影响传送文件、视频聊天等功能，珊瑚虫新增加的功能对原来的影响都尽可能的小。这个库很多内容是参考LumaQQ。因此Quaful把Luma等人也列为作者。<br />在跟Quaful通过几次邮件后，作者个人的看法是珊瑚虫4.0最重大的变化在于，原来主要是截获内存里面的东西，现在是直接截获一个个网络包。<br />原来的方法基本上不用了解QQ的通讯协议，背后的方法是要深入到QQ的协议里面去。<br />原来的方法如果QQ重新写过一个客户端，尤其是更改一下获得IP地址的函数名字等，那么IPQQ基本上要重新来过一次。而采用4.0的方式基本上没有这个后顾之忧。它所需要做的是重新钩一个窗体而已，因为腾讯不会不顾通讯协议的不兼容而抛弃大量的用户的。<br />从技术思想上来说，原来的方法是紧密依靠QQ，现在呢是我只是依靠QQ一下而已。<br />对于这款外挂我曾经建议过Quaful用驱动的方式来写，也就是我能知道QQ的任意一个包，发给谁，是什么IP与端口。因为用驱动写是直接到网络的低层，占用的系统资源更少，但开发的工作量要增加非常的多。从工程的角度上来讲并不划算。<br />我把这个想法告诉Quaful后，他一直打击我的看法。Quaful声称：“用驱动层拦截QQ包并不会比现在更省资源。无论是TDI还是NDIS，对系统的影响都是全局的，不仅会影响QQ，还会影响所有的应用程序。这是更加消耗系统资源的做法。”<br />作者曾试图在Win2k的DDK包中根据相关的例子来分析，但发现工作巨大，因此放弃。但从相关的效果上看，Quaful是对的。从驱动层来写，的确对系统的影响是全局的。但我认为这种写法更有扩充性。<br />五、总结<br />在不同时期的IPQQ中我们看到了他们之间的继承关系。如果深入到最核心的技术中去考察这个问题，我们可以看到，四个IPQQ可以用如下的话来概括。<br />1、邹丹，我第一个改QQ。<br />2、木子，我改QQ改出套路来了。<br />3、Cygwin，我在运行的时候改QQ。<br />4、Quaful，QQ你改吧，你怎么改我都能逮住你。<br />此外，我们也可以看到其它一些作者的思路。<br />1、&nbsp;&nbsp;&nbsp;&nbsp; 木子、珊瑚虫你能改QQ我能改你！<br />2、&nbsp;&nbsp;&nbsp;&nbsp; 木子、珊瑚虫你先改吧，我学你的样改。<br /><br />在上述四个IPQQ中作者最欣赏珊瑚虫4.0，个人认为其发展的方向非常多。当然目前的版本是通过sokect来分析的。这样做相对来说比较占内存，速度也不够快。 <br /><br />文中涉及到如下人物：<br />作者： 疯狂绅士&nbsp;&nbsp; 原水木清华黑客版版主 <br /><br />作者：RunJin&nbsp;&nbsp; 飘云的老大 现读本科二年级<br /><br />邹丹，78年出生<br />木子，姓名保密<br />Cygwin，姓名 保密 原水木清华黑客版版主 <br />Soff&nbsp;&nbsp; 姓名 保密 北京理工大学当老师<br />Quaful，姓名 保密&nbsp;&nbsp; 清华大学在读博士 <br /> <br /><br /> <br /><br />编写QQ外挂插件的原理和方法<br /> <br /><br /> <br /><br />前一段时间研究了下QQ目前各种外挂的机理，包括著名的coralQQ。鉴于目前网上关于这方面的文章少之又少，一般能找到的应该就这下面3篇(由于可能涉及版权问题，我链接就不给出了：<br /><br />　　a.木子版显IPQQ的制作教程<br /><br />　　b.关于QQ外挂DLL的加载原理的分析<br /><br />　　c.明日帝国(sunwangme)写的我是这样来做破解qq，做QQ外挂的系列<br /><br />　　在开始我的分析前我简要对上面这些资料作下评价，首先我觉得如果你也想写个类似的外挂插件，他们的文章你是必看的，而且特别是你想真的写出什么有用的东西的话，明日帝国得文章一定要看，而且必须看懂。对于木子版的教程应该说是最早“公开”的资料了，很多人都是看了这个教程开始写自己的外挂的。但是他通过直接修改QQ来做显IP补丁，可能引起的法律问题不说(如果你只是自娱自乐的话)，他不能适应不同版本的QQ，而且用户也不太能接受直接的修改，而且教程已经不能直接用于目前版本的QQ了。<br /><br />　　第二个教程是做外挂DLL插件必看的，但是他丝毫没涉及显示IP的问题，只是简单介绍了DLL注入的问题，并对win9x环境下手动加载dll到进程空间作了分析。但是目前win9x已逐渐退出舞台，所以一般只要使用Cr&#101;ateRemoteThread即可。<br /><br />　　第一部分:<br /><br />　　1.1 主流的外挂插件如何获取IP和其他信息的?<br /><br />　　也许你会认为他拦截了底层的Socket通讯?当然不至于，但这样肯定是最有效的办法。<br /><br />　　让我们换个思路:如果你现在需要和一个QQ好友传输文件或者进行语音聊天或者发送了图片或自定义表情。那么QQ必须知道对方的IP地址和端口信息，这样才能把数据传给对方。<br /><br />　　所以，很有可能QQ内部已经实现了获取IP地址和其他信息的相关函数了。的确如此。这也是木子版QQ教程里面提到的办法，调用QQ内部的函数。<br /><br />　　下面是截至QQ组件之一的CQQApplication.dll中的汇编代码:(建议先浏览木子版QQ的教程)<br /><br />　　027832C7 8B45 F0 mov eax,dword ptr ss:[ebp-10]<br />　　027832CA 53 push ebx<br />　　027832CB 68 38558302 push CQQAppli.02835538 ; ASCII dwIP<br />　　027832D0 50 push eax<br />　　027832D1 8B08 mov ecx,dword ptr ds:[eax]<br />　　027832D3 FF51 18 call dword ptr ds:[ecx+18]<br />　　027832D6 8B45 F0 mov eax,dword ptr ss:[ebp-10]<br />　　027832D9 53 push ebx<br />　　027832DA 68 40558302 push CQQAppli.02835540 ; ASCII wPort<br />　　027832DF 50 push eax<br />　　027832E0 8B08 mov ecx,dword ptr ds:[eax]<br />　　027832E2 FF51 14 call dword ptr ds:[ecx+14] <br /><br /> 　　CQQApplication.dll通俗来说就是负责显示和实现QQ聊天窗口的模块。就是那些和xxx聊天中的窗口，所以这就是为什么要在其中寻找这样的代码的依据。<br /><br />　　从上面的汇编来看，显然是调用了2个thiscall规范的函数，也就是我们所说的C++类成员函数。<br /><br />　　2个成员函数的的大致形式是this-&gt;Func(void *ptr1,char *cmd,DWORD *ptr2);其中cmd就是上面dwIP、wPort这些字符串，而ptr2也很容易知道是函数返回值得存储指针。现在关键是要获取this指针，也就是ecx寄存器的数据和ptr1这个神秘指针的数据。<br /><br />　　如果你有兴趣反汇编CoralQQ中相关的代码，也会发现与上面类似的调用部分。<br /><br />　　这里暂时不深入这些函数的作用和那个cmd指针的细节，我们先来研究如何获取this指针和ptr2吧。<br /><br />　　注意<br /><br />　　027832DF 50 push eax<br /><br />　　027832E0 8B08 mov ecx,dword ptr ds:[eax]<br /><br />　　这2段代码，也就是说ptr2获取了，那么this指针也可以得到。所以现在一切的关键就是找出ptr2的来历。这样我们就能很轻松的实现显示ip了。<br /><br />　　1.2 神秘的ptr2指针<br /><br />　　为了能更快的说明问题，这里就不厚道的引用CoralQQ.dll的汇编了~<br /><br />　　0056D97F 51 push ecx<br />　　0056D980 52 push edx<br />　　0056D981 50 push eax<br />　　0056D982 FF15 38AB5A00 call dword ptr ds:[5AAB38] ; BasicCtr.GetFriendQQData<br />　　0056D988 8B4424 14 mov eax,dword ptr ss:[esp+14]<br />　　0056D98C 83C4 0C add esp,0C<br />　　0056D98F 3BC3 cmp eax,ebx<br />　　0056D991 0F84 03020000 je CoralQQ.0056DB9A<br />　　0056D997 57 push edi<br />　　0056D998 895C24 14 mov dword ptr ss:[esp+14],ebx<br />　　0056D99C 8D5424 14 lea edx,dword ptr ss:[esp+14]<br />　　0056D9A0 52 push edx<br />　　0056D9A1 68 50BB5900 push CoralQQ.0059BB50<br />　　0056D9A6 C64424 30 01 mov byte ptr ss:[esp+30],1<br />　　0056D9AB 8B08 mov ecx,dword ptr ds:[eax]<br />　　0056D9AD 68 C8BA5900 push CoralQQ.0059BAC8 ; ASCII QQUSER_DYNAMIC_DATA<br />　　0056D9B2 50 push eax<br />　　0056D9B3 8B41 54 mov eax,dword ptr ds:[ecx+54]<br />　　0056D9B6 FFD0 call eax<br />　　0056D9B8 8B4424 14 mov eax,dword ptr ss:[esp+14]<br />　　0056D9BC 3BC3 cmp eax,ebx<br />　　0056D9BE 0F84 F9000000 je CoralQQ.0056DABD<br />　　0056D9C4 8B08 mov ecx,dword ptr ds:[eax]<br />　　0056D9C6 8D5424 1C lea edx,dword ptr ss:[esp+1C]<br />　　0056D9CA 52 push edx<br />　　0056D9CB 68 ACA15900 push CoralQQ.0059A1AC ; ASCII wProcotol<br />　　0056D9D0 50 push eax<br />　　0056D9D1 8B41 30 mov eax,dword ptr ds:[ecx+30]<br />　　0056D9D4 FFD0 call eax<br />　　0056D9D6 8B4424 14 mov eax,dword ptr ss:[esp+14]<br />　　0056D9DA 8B08 mov ecx,dword ptr ds:[eax]<br />　　0056D9DC 8D5424 10 lea edx,dword ptr ss:[esp+10]<br />　　0056D9E0 52 push edx<br />　　0056D9E1 68 94A15900 push CoralQQ.0059A194 ; ASCII dwRecentIP<br />　　0056D9E6 50 push eax<br />　　0056D9E7 8B41 34 mov eax,dword ptr ds:[ecx+34]<br />　　0056D9EA FFD0 call eax <br /><br />　　以上代码正式coralQQ 4.5版获取IP信息的片断。我们只需要关注上面的0056D982和0056D9B6地址的2个调用函数。<br /><br />　　为什么这样说了，先看下面获取dwRecentIP数据的代码，它和上面提到的那个成员函数是属于一个类的(这里没提供出完整代码，你可以自己验证下:-P)。那么这里的this指针从哪里来呢?<br /><br />　　0056D9DA 8B08 mov ecx,dword ptr ds:[eax]<br /><br />　　0056D9D6 8B4424 14 mov eax,dword ptr ss:[esp+14]<br /><br />　　按照thiscall规范，ecx就保存了this指针，上面代码说明ecx是来自[esp+14]的，我们再往上看:<br /><br />　　0056D99C 8D5424 14 lea edx,dword ptr ss:[esp+14]<br />　　0056D9A0 52 push edx<br />　　0056D9A1 68 50BB5900 push CoralQQ.0059BB50<br />　　0056D9A6 C64424 30 01 mov byte ptr ss:[esp+30],1<br />　　0056D9AB 8B08 mov ecx,dword ptr ds:[eax]<br />　　0056D9AD 68 C8BA5900 push CoralQQ.0059BAC8 ; ASCII QQUSER_DYNAMIC_DATA<br />　　0056D9B2 50 push eax<br />　　0056D9B3 8B41 54 mov eax,dword ptr ds:[ecx+54]<br />　　0056D9B6 FFD0 call eax <br /><br />　　看到么0056D99C lea edx,dword ptr ss:[esp+14]!!<br /><br />　　也就是说this指针和ptr2时由这个函数获得的，我们暂时以它的一个参数命名:QQUSER_DYNAMIC_DATA。<br /><br />　　但不幸的是，这个函数同样也是thiscall调用规范的，也就说也是需要得到this指针……不过不慌:<br /><br />　　0056D97F 51 push ecx<br />　　0056D980 52 push edx<br />　　0056D981 50 push eax<br />　　0056D982 FF15 38AB5A00 call dword ptr ds:[5AAB38] ; BasicCtr.GetFriendQQData<br />　　0056D988 8B4424 14 mov eax,dword ptr ss:[esp+14] <br /><br />　　0056D9AB 8B08 mov ecx,dword ptr ds:[eax] <br /><br />　　注意上面2段代码，QQUSER_DYNAMIC_DATA函数的this指针最终是[esp+14]，而esp+14的数据是<br /><br />　　0056D97F 51 push ecx<br /><br />　　这段代码压入的。所幸的是GetFriendQQData是个导出函数(位于BasicCtrDll.dll)，我们看看他的申明:<br /><br />　　int GetFriendQQData(struct IQQCore *,unsigned long,struct IQQData * *);<br /><br />　　上面这个push ecx实际上是压入了参数struct IQQData * *。<br /><br />　　所以现在的只要获得struct IQQCore *,和第二个神秘参数的含义就能实现显示IP的功能了。<br /><br /><br />1.3 IQQCore和Uin<br /><br />　　int GetFriendQQData(struct IQQCore *,unsigned long,struct IQQData * *);<br /><br />　　这个函数，从而获得那个struct IQQData *指针。但问题就是要调用这个函数必须要提供2个参数:IQQCore <em>和一个unsigned long(DWORD)的神秘数据。<br /><br />　　在开始正式分析前请各位思考下，如果要你编写一个能显示好友IP的函数，你需要先知道什么呢?<br /><br />　　至少需要知道要去获取哪个QQ好友吧。这个肯定是必须的，否则函数就没有执行的意义了<br /><br />　　现在我们跟踪下上面这个GetFriendQQData函数。在其入口点下断点。然后小心的把鼠标移动到QQ好友列表中某个头像上(需要使用CoralQQ……有点不厚道)。这时候应该程序就会被断下。<br /><br />　　因为正常理鼠标移至好友头像会显示信息卡片，CoralQQ会在下面显示IP信息，所以按照上一篇文章反汇编的代码，GetFriendQQData必然会调用。我们从堆栈里面找到这个unsigned long对应的数据:<br /><br />　　0x1A53836<br /><br />　　因为是DWORD数据，把它转化为10进制看看:27605046<br /><br />　　这不是我的QQ号码么……的确，先前鼠标是移动在我的头像上了。<br /><br />　　所以可以猜测这个unsigned long就是好友的QQ号码。<br /><br />　　经过多次验证，的确如此。<br /><br />　　所以，这个神秘的unsigned long明确:他是要获取好友信息的号码,顺便补充下，这个unsigned long在QQ中可是有专门名字的:Uin<br /><br />　　接下来就是struct IQQCore</em>，我想他的作用从名字中应该就能猜出大概来。虽然具体他的结构我还没弄清，但可以肯定他好比是QQ程序内核信息的指针。而现在最关键的问题是如何去获得它。<br /><br />　　如果你研究过BasicCtrlDll.dll中导出的函数，你会发现几乎一半的函数的参数都由这个IQQCore，比如:<br /><br />　　int GetCurrentStatus(struct IQQCore *,int *)<br />　　int GetCurrentUin(struct IQQCore *,unsigned long *)<br />　　int GetFriendStat(struct IQQCore *,unsigned long) <br /><br />　　那么我们就拦截其中的一部分函数，看看提供给他们的这个struct IQQCore *参数具体是什么。<br /><br />　　如果你的确这样做了，那么会发现所有的函数，无论在什么时候，这个struct IQQCore *的值是确定的唯一的。如果你这个IQQCore *指针的地址区域下内存写入断点的话会发现struct IQQCore *实际上在QQ进行登录初始化时就创建了，以后就不再被修改。<br /><br />　　所以现在的问题就很简单了，我们可以暂时不用理会struct IQQCore *到底是什么，只要能获取到他就ok<br /><br />　　1.4 如何获取struct IQQCore *?<br /><br />　　如果只是调试个QQ，得到struct IQQCore *是非常容易的，但记住我们是要编写外挂。所以就是说我们要问:外挂如果通过程序来获取这个指针呢?<br /><br />　　最野蛮的办法:把外挂写成一个调试器，模拟手工调试的过程，获得这个IQQCore *。ok，我很佩服你这样做，这也是我原先的想法。虽然写这个一个调试器是很简单的，但是他基本上没有实际意义，因为不能应对各种版本的QQ程序，而且也就无法再使用OD这些调试器来调试你的程序了<br /><br />　　下面的方法要感谢明日帝国(sunwangme)写的教程了，可能一开始你看他教程会不知所云，但相信你现在去看他的文章就会很有感触。<br /><br />　　上面说过这个IQQCore 是不会改变的，而且BasicCtrlDll.dll导出的那么多函数又偏偏要用到他，为什么不去拦截一个有IQQCore *参数的函数来获取这个IQQCore *呢?<br /><br />　　具体的做法我会在编写插件时说明。可能你会想拦截导出函数(也就是API)不也是调试器作的事么?其实也有别的办法，这里就是用API Hook技术来实现的(建议先了解下win32的hook技术)。<br /><br />　　问题是API SetWindowsHookEx是不可能hook一个API的。所以这里要用比较“底层”的办法:<br /><br />　　一个导出函数的入口内存地址可以用GetProcAddress API获取，我们只要修改程序的代码，使得他在原先函数入口点执行时跳入我们的函数取执行，然后再跳转回来即可。(实际做法不是这样，在说明如何编写插件时我会说到)<br /><br />　　现在问题就是要在BasicCtrlDll.dll导出函数中选取一个比较理想的函数取拦截，得到IQQCore<br /><br />　　要拦截的函数应该具有如下特点:<br /><br />　　函数形参简单，最好只有IQQCore *一个参数<br /><br />　　函数能尽早被调用，这样能及早的获取IQQCore *<br /><br />　　函数不能是thiscall规范的，也就是说函数必须是全局函数，不是一个成员函数<br /><br />　　为何要这些特点应该都能理解，我对最后一个做下说明，thiscall规范的函数还需要一个类的this指针地址，这会给拦截造成一定麻烦(今后就会遇到这样的情况，以后再讨论)。<br /><br />　　最终我们选取的函数是QQHelperDll.dll中的一个导出函数:<br /><br />　　int IsLogin(struct IQQCore *);<br /><br />　　很满足我们的要求，而且用OD跟踪发现，他在QQ登录后就不停的调用，太爽了……<br /><br />　　总结一下:要获取struct IQQCore *通过拦截API获取参数实现，我们拦截的函数选用了IsLogin()。<br /><br />　　1.5 Uin和struct IQQData *<br /><br />　　现在还有2个问题要去研究，第一，在调用GetFriendQQData时候，Uin(就是那个unsigned long参数)如何确定呢?<br /><br />　　这个问题要等到我介绍插件编写时在讨论，但可以先做下暗示，我们编写的插件是需要在打开和好友聊天的对话框以及将鼠标移动到好友头像上时，显示对方的IP信息，就第一个情况:QQ的聊天对话框里面不就有好友的QQ号码(Uin)么?第二个情况:虽然探出的信息卡片没有号码，但可以猜测QQ也是先需要获取相关信息的。<br /><br />　　现在我们再说说这个IQQData *的作用，看看BasicCtrlDll.dll的一些导出函数:<br /><br />　　long GetQQDataBuf(struct IQQData *,char const *,class CString &amp;)<br />　　long GetQQDataStr(struct IQQData *,char const *,class CString &amp;) <br /><br />　　其中需要IQQData *参数，那么我们看看这些函数有什么作用呢?以GetQQDataStr在CoralQQ中的使用情况为例:<br /><br />　　0056DAC4 57 push edi<br />　　0056DAC5 68 DCBA5900 push CoralQQ.0059BADC ; ASCII NAME<br />　　0056DACA 52 push edx<br />　　0056DACB FF15 44AB5A00 call dword ptr ds:[5AAB44] ; BasicCtr.GetQQDataStr<br />　　0056DAE5 8B4424 24 mov eax,dword ptr ss:[esp+24]<br />　　0056DAE9 8D56 34 lea edx,dword ptr ds:[esi+34]<br />　　0056DAEC 52 push edx<br />　　0056DAED 68 ECBA5900 push CoralQQ.0059BAEC ; ASCII REMARK_REALNAME<br />　　0056DAF2 50 push eax<br />　　0056DAF3 FF15 44AB5A00 call dword ptr ds:[5AAB44] ; BasicCtr.GetQQDataStr<br />　　0056DAF9 8B5424 30 mov edx,dword ptr ss:[esp+30]<br />　　0056DAFD 8D4E 38 lea ecx,dword ptr ds:[esi+38]<br />　　0056DB00 51 push ecx<br />　　0056DB01 68 FCBA5900 push CoralQQ.0059BAFC ; ASCII COUNTRY<br />　　0056DB06 52 push edx<br />　　0056DB07 FF15 44AB5A00 call dword ptr ds:[5AAB44] ; BasicCtr.GetQQDataStr<br />　　0056DB0D 8B4C24 3C mov ecx,dword ptr ss:[esp+3C]<br />　　0056DB11 8D46 3C lea eax,dword ptr ds:[esi+3C]<br />　　0056DB14 50 push eax<br />　　0056DB15 68 04BB5900 push CoralQQ.0059BB04 ; ASCII PROVINCE<br />　　0056DB1A 51 push ecx<br />　　0056DB1B FF15 44AB5A00 call dword ptr ds:[5AAB44] ; BasicCtr.GetQQDataStr <br /><br />　　这些代码是在获取IP信息后出现的，猜猜在做什么呢?NAME，COUNTRY，PROVINCE这些词汇来看，应该是在获取当前要显示ip好友的名字、国籍、省份。而具体的执行函数就是GetQQDataStr。<br /><br />　　再结合这个函数的参数来看，IQQData *,很有可能就是存放着一个用户相关信息的结构<br /><br />　　事实也是如此的，到目前为止编写QQ外挂插件的条件已经具备。<br /><br /><br /> <br /><br />2.编写QQ显IP插件<br /><br />　　2.1 编写加载外挂dll的程序<br /><br />　　这里采用VC作为开发环境，我使用的是VS2005<br /><br />　　首先说下大体的思路:<br /><br />　　这里仿造coralQQ一样，将真正的外挂代码写入dll，然后编写一个exe文件去加载qq.exe，并把我们写得dll注入。<br /><br />　　这一步在前一篇文章中已经给出了具体代码。<br /><br />　　2.2 编写插件主体<br /><br />　　感觉自己如果一涉及具体代码就回说不来话，所以这次就先谈思路，然后给出部分代码。<br /><br />　　dll要做的事:<br /><br />　　将我们前面分析过的关键API挂钩，以便得到IQQCore *，Uin，以及在qq聊天窗口弹出时进行捕获以便显示IP信息。<br /><br />　　要做到上面的要求，首先就是要在dll加载后开始做API hook的工作。<br /><br />　　不过这件事情不能在DllMain里面写，推荐的做法是在DllMain里面创建一个新的线程，线程的执行函数我们设为:WorkerProc(VC编写的话推荐用_beginthread创建这个线程，否则无法使用CRT函数)，为什么不能直接在DllMain里面写我稍候分析<br /><br />　　然后就是在WorkerProc里面写入具体的hook代码。<br /><br />　　1.拦截QQHelperDll.dll中的IsLogin函数<br /><br />　　前面分析过了，IQQCore *指针可以通过拦截这个API来获取。<br /><br />　　这里我们采用的是《windows核心编程》中推荐的拦截API hook的办法(修改入口地址跳转相对他烦了些，而且我们这里只是想做hook):通过动态修改API调用者模块的IAT表，将原先API的入口地址替换成我们函数的。具体的替换代码我们就采用书中提供的了的ReplaceIATEntryInOneMod(见前一篇)。<br /><br />　　现在要注意一个问题，我们用来替换原先API的函数必须和原函数采用同样的调用规范，这个IsLogin本身就是cdecl得，所以只要用个形参和返回值一样的函数取替换即可:<br /><br />　　给出实现本功能的代码:<br /><br />　　typedef int (*OrgIsLogin)(DWORD ptrIQQCore);<br />　　int PokeIsLogin(DWORD ptrIQQCore)<br />　　{<br />　　　global_ptrIQQCore &#x3D; ptrIQQCore;<br />　　　return ((OrgIsLogin)(PROC)OrgIsLoginProc)(ptrIQQCore);<br />　　}<br /><br />　　&#x2F;&#x2F;&#x2F;&#x2F;下面代码在WorkerProc函数中&#x2F;&#x2F;&#x2F;<br /><br />　　OrgIsLoginProc &#x3D; GetProcAddress( GetModuleHandleA(QQHelperDll.dll),?IsLogin@@YAHPAUIQQCore@@@Z);<br />　　if (ReplaceIATEntryInOneMod(QQHelperDll.dll,OrgIsLoginProc,(PROC)&amp;PokeIsLogin,GetModuleHandleA(qq.exe)))<br />　　{<br />　　　&#x2F;&#x2F;替换成功<br />　　}<br />　　&#x2F;&#x2F; <br /><br />　　今后，只要QQ.exe调用IsLogin，我们的PokeIsLogin函数就会调用，并把IQQCore纪录下来，注意替换的函数要最后去调用原函数，否则就会让程序崩溃。<br /><br />　　2.拦截SetForegroundWindow API<br /><br />　　拦截该API是因为每次弹出新的QQ聊天窗口时，CQQApplication.dll都会去调用它，以便把聊天窗口至于前景显示。所以拦截CQQApplication.dll对他的调用就能在由新的聊天窗口出现时调用我们插件的代码去显示IP信息，而不必傻傻的去写循环等待了<br /><br />　　这里就要注意SetForegroundWindow 是采用stdall调用规范的，所以别忘在替换函数名前加上__stdcall(或WINAPI宏)标记。<br /><br />　　该部分的替换代码如下:<br /><br />　　typedef BOOL ( __stdcall *OrgSetForegrandWindow)(HWND hWnd);<br />　　extern C BOOL APIENTRY OnQQWndShow(HWND hWnd)<br />　　{<br />　　　bool trueResult &#x3D; ((OrgSetForegrandWindow)(PROC)OrgFuncProc)(hWnd);<br />　　　return trueResult;<br />　　}<br />　　&#x2F;&#x2F;下面代码在WorkerProc函数或由其调用的函数中<br />　　OrgFuncProc &#x3D; GetProcAddress( GetModuleHandleA(user32),SetForegroundWindow);<br />　　if (ReplaceIATEntryInOneMod(user32.dll,OrgFuncProc,(PROC)&amp;OnQQWndShow,global_hCQQAppModule))<br />　　{<br />　　　&#x2F;&#x2F;替换函数入口成功<br />　　} <br /><br />　　其中global_hCQQAppModule是CQQApplication.dll在qq.exe中的模块句柄，可以调用GetModuleHandleA(CQQApplication.dll)来实现。不过现在存在一个问题<br /><br />　　用od加载qq.exe就会发现实际上CQQApplication.dll并不是在qq.exe启动后加载的，而是在登录以后。所以如果我们的dll插件在被加载之后立刻调用GetModuleHandleA的话就会返回NULL，那么之后的函数替换就不可能实现了。<br /><br />　　这里我用了个比较笨的办法，在替换SetForegroundWindow前编写循环不断的去掉用GetModuleHandleA，直到返回非null，而为了防止频率过快可以在循环中加上Sleep函数。(之前也尝试loadlibrary提前加载，但一直失败。还有中办法就是从前面的IsLogin来判断是否登录了QQ。但没有试验过。总之如果你有比较好的办法也希望告诉我)<br /><br />　　这部分的代码如下:<br /><br />　　bool WaitforLogon()<br />　　{<br />　　　while(!bIsDllUnload)<br />　　　{<br />　　　　global_hCQQAppModule &#x3D; GetModuleHandleA(CQQApplication.dll);<br />　　　　if (global_hCQQAppModule) return true;<br />　　　　Sleep(300);<br />　　　}<br />　　　return false;<br />　　} <br /><br /><br />　　这就是为什么前面说过不能再dllmain里面作函数替换的工作了，否则会导致dllmain无法退出，从而会锁死整个qq<br /><br /><br /> <br /><br />3.获取Uin<br /><br />　　现在IQQCore *已经获得了，同时只要在OnQQWndShow中写入得到用户IP信息的代码，再使用FindWindow的方法把原先的广告去除，再创建个Edit或者Static来显示我们的数据即可。<br /><br />　　但之前还要得到Uin，也就是对方好友的QQ号。<br /><br />　　其实这里有个很笨的办法:QQ聊天对话框中有对方的号码的:比如“&amp;heaven(27605046)(后面是个性签名)。的确可以用FindWindow+GetWindowText获取，然后得到括号里面的数据就好了，但是是否有更简单办法呢?有<br /><br />　　这里要感谢明日帝国(sunwangme)的教程，这里就是用他的方法了，具体原理还是大家去他blog看吧(google一下)<br /><br />　　大体的方法是:在QQ准备显示聊天对话框时，上面“&amp;heaven(27605046)(后面是个性签名)这段文字会调用位于QQBaseClassInDll.dll中的CAllInOneStatusBar::SetUin(unsigned long);这个函数，其中参数就是我们要的QQ号了。而且可以保证CQQApplication.dll仅仅在要显示对话框前才会调用它。(再次感谢明日帝国)<br /><br />　　所以和上面一样，这次拦截CAllInOneStatusBar::SetUin(unsigned long);<br /><br />　　OrgSetUINProc &#x3D;<br />　　GetProcAddress(GetModuleHandleA(QQBaseClassInDll.dll),?SetUin@CAllInOneStatusBar@@QAEX_J@Z);<br />　　if (ReplaceIATEntryInOneMod(QQBaseClassInDll.dll,OrgSetUINProc,(PROC)&amp;Poke_GETUIDA,global_hCQQAllInOne)){<br />　　} <br /><br />　　今后就会先调用我们的OrgSetUINProc，其中获取参数即可。<br /><br />　　不过要注意2个问题，第一这个QQBaseClassInDll.dll也不是一开始加载，更不是在登录后加载，而是在第一次要显示QQ聊天窗口才加载，不过比较幸运的是可以直接LoadLibrary把它先载过来。<br /><br />　　还有一个问题就是SetUin是thiscall规范的……哎，自己对thiscall还不是很了解，所以怕出错，那个OrgSetUINProc只能用naked调用规范了，同时要自己写汇编去完成细节的事:<br /><br />　　__declspec( naked ) int Poke_GETUIDA()<br />　　{<br />　　　_asm<br />　　　{<br />　　　　push ecx<br />　　　　mov ecx,[esp+8]<br />　　　　mov dwRecentUINA,ecx<br />　　　　pop ecx<br />　　　　jmp o&#114;gSetUINProc<br />　　　}<br />　　} <br /><br />　　ok，这样一切都完成了<br /><br />　　3.编写获取IP信息的代码<br /><br />　　先整理下上面我们3个替换函数的执行顺序:<br /><br />　　PokeIsLogin:最好执行，且今后不断被调用<br /><br />　　Poke_GETUIDA:在将要显示QQ聊天窗口时执行<br /><br />　　OnQQWndShow:在Poke_GETUIDA之后运行。<br /><br />　　所以可以保证在OnQQWndShow中可以得到我们获取IP信息所有必要的参数了。<br /><br />　　那么就开始编写获取IP的代码:<br /><br />　　按照前面分析的，先用BasicCtr.GetFriendQQData得到当前好友的IQQData *:<br /><br />　　DWORD MainHandle;<br />　　if (ptrBasicCtr_GetFriendQQData&#x3D;&#x3D;NULL || global_ptrIQQCore&#x3D;&#x3D;NULL) return 0;<br />　　_asm<br />　　{<br />　　　mov edx,dwID<br />　　　mov eax,global_ptrIQQCore<br />　　　lea ecx,MainHandle<br />　　　push ecx<br />　　　push edx<br />　　　push eax<br />　　　call ptrBasicCtr_GetFriendQQData ; BasicCtr.GetFriendQQData<br />　　　add esp,0xC<br />　　} <br /><br />　　其中dwID是Uin，即用DWORD保存的QQ号码<br /><br />　　global_ptrIQQCore就是前面获得的IQQCore *<br /><br />　　ptrBasicCtr_GetFriendQQData 是GetFriendQQData的入口地址，用GetProcAddress得到<br /><br />　　最终MainHandle将保存IQQData *，如果运行失败，会返回null<br /><br />　　接下来就是通过QQUSER_DYNAMIC_DATA(暂时命名)函数来得到动态信息类的指针:<br /><br />　　char *szQQUSER_DYNAMIC_DATA &#x3D; QQUSER_DYNAMIC_DATA;<br />　　DWORD tmpInfo;<br />　　DWORD returnVal;<br />　　tmpInfo &#x3D; 0xba863a1e;<br /><br />　　if (mainHandle &#x3D;&#x3D; NULL)<br />　　{<br />　　　return NULL;<br />　　}<br /><br />　　_asm<br />　　{<br />　　　mov eax,mainHandle<br />　　　lea edx,returnVal<br />　　　push edx<br />　　　lea edx,tmpInfo<br />　　　push edx<br />　　　mov ecx,[eax]<br />　　　push szQQUSER_DYNAMIC_DATA<br />　　　push eax<br />　　　call [ecx+54h]<br />　　} <br /><br />　　结果将保存在returnVal中，同样，如果执行错误returnVal&#x3D;NULL<br /><br />　　最后就是去获取IP地址了<br /><br />　　char *szwProcotol &#x3D; wProcotol;<br />　　char *szRecentip&#x3D;dwRecentIP;<br />　　char *szwRecentPort&#x3D;wRecentPort;<br />　　char *szdwC2CIP&#x3D;dwC2CIP;<br />　　char *szwC2CPort&#x3D;wC2CPort;<br />　　char *szdwIP&#x3D;dwIP;<br />　　char *szwPort&#x3D;wPort;<br />　　bool GetDestIPInfo(DWORD ptrClassHandle,DWORD *ptrDestIp,DWORD *ptrDestPort)<br />　　{<br />　　　if (ptrClassHandle&#x3D;&#x3D;NULL || ptrDestIp&#x3D;&#x3D;NULL || ptrDestPort&#x3D;&#x3D;NULL) return false;<br />　　　&#x2F;&#x2F;Using Std Info Buffer<br />　　　_asm<br />　　　{<br />　　　　pushad<br />　　　　pushf<br />　　　　mov eax,ptrClassHandle<br />　　　　mov ecx,[eax]<br />　　　　mov edx,ptrDestIp<br />　　　　push edx<br />　　　　push szRecentip<br />　　　　push eax<br />　　　　mov eax,[ecx+34h]<br />　　　　call eax<br />　　　　mov eax,ptrClassHandle<br />　　　　mov ecx,[eax]<br />　　　　mov edx,ptrDestPort<br />　　　　push edx<br />　　　　push szwRecentPort<br />　　　　push eax<br />　　　　mov eax,[ecx+30h]<br />　　　　call eax<br />　　　　popf<br />　　　　popad<br />　　　}<br />　　　(*ptrDestPort) &amp;&#x3D; 0xFFFF;<br />　　　if ((*ptrDestIp) !&#x3D; NULL &amp;&amp; (*ptrDestPort) !&#x3D; NULL) return true;<br />　　　_asm<br />　　　{<br />　　　　pushad<br />　　　　pushf<br />　　　　mov eax,ptrClassHandle<br />　　　　mov ecx,[eax]<br />　　　　mov edx,ptrDestIp<br />　　　　push edx<br />　　　　push szdwC2CIP<br />　　　　push eax<br />　　　　mov eax,[ecx+34h]<br />　　　　call eax<br />　　　　mov eax,ptrClassHandle<br />　　　　mov ecx,[eax]<br />　　　　mov edx,ptrDestPort<br />　　　　push edx<br />　　　　push szwC2CPort<br />　　　　push eax<br />　　　　mov eax,[ecx+30h]<br />　　　　call eax<br />　　　　popf<br />　　　　popad<br />　　　}<br />　　　(*ptrDestPort) &amp;&#x3D; 0xFFFF;<br />　　　if ((*ptrDestIp) !&#x3D; NULL &amp;&amp; (*ptrDestPort) !&#x3D; NULL) return true;<br />　　　_asm<br />　　　{<br />　　　　pushad<br />　　　　pushf<br />　　　　mov eax,ptrClassHandle<br />　　　　mov ecx,[eax]<br />　　　　mov edx,ptrDestIp<br />　　　　push edx<br />　　　　push szdwIP<br />　　　　push eax<br />　　　　mov eax,[ecx+34h]<br />　　　　call eax<br />　　　　mov eax,ptrClassHandle<br />　　　　mov ecx,[eax]<br />　　　　mov edx,ptrDestPort<br />　　　　push edx<br />　　　　push szwPort<br />　　　　push eax<br />　　　　mov eax,[ecx+30h]<br />　　　　call eax<br />　　　　popf<br />　　　　popad<br />　　　}<br />　　　(*ptrDestPort) &amp;&#x3D; 0xFFFF;<br />　　　return ((*ptrDestIp) !&#x3D; NULL &amp;&amp; (*ptrDestPort) !&#x3D; NULL);<br />　　} <br /><br />　　ptrClassHandle是前面得到的returnVal，IP地址的DWORD数据和WORD的port信息将保存在后2个参数指针的地址中。(代码借鉴了CoralQQ)<br /><br />　　到目前为止已大功告成!其他的细节代码就请各位发挥吧<br /><br />　　4.扩展<br /><br />　　上面并没有介绍如何得到对方QQ版本的信息，其实和获取IP一样，你在CQQApplication.dll中找到wProcotol的字符串参考，就会发现它和获取IP的代码很像，直接抄下来用就是了。<br /><br /></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2007/10/08/52-%E8%B7%A8%E8%BF%9B%E7%A8%8BAPI%20Hook/">跨进程API Hook</a><a class="next" href="/2007/10/06/55-VB%E4%B8%ADapi%20hook/">VB中api hook</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://anthoney.github.io"/></form></div><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://anthoney.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/yontaw" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@from2.net" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/anthoney" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GIS/">GIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E6%96%87%E5%9C%B0%E7%90%86/">人文地理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%83%E5%96%9D%E7%8E%A9%E4%B9%90/">吃喝玩乐</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%96%E8%AF%AD/">外语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%B1%E9%9F%B3%E5%9B%BE%E5%BD%A2/">影音图形</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E8%B7%AF/">心路</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/">软件技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A3%9E%E8%A1%8C%E6%A2%A6%E6%83%B3/">飞行梦想</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E7%BE%A4%E6%99%96/" style="font-size: 15px;">群晖</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/%E7%BD%91%E7%9B%98/" style="font-size: 15px;">网盘</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/08/14/457-%E7%BE%A4%E6%99%96docker%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E6%B3%A8%E5%86%8C%E8%A1%A8%E4%BD%86%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">群晖docker可以访问注册表但无法下载的解决方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/10/456-%E7%A9%BA%E9%97%B4%E5%88%B0%E6%9C%9F%E6%8D%A2/">用了17年的域名空间到期了，换了一个新的</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/30/455-FlexNet%20lmtools%20license%20vitual%20adapter%20Revit%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1/">FlexNet lmtools license vitual adapter Revit配置虚拟网卡</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/08/454-%E6%88%BF%E5%B1%8B%E5%9D%90%E5%90%91%E4%BB%A5%E4%BB%80%E4%B9%88%E4%B8%BA%E5%87%86%20%E6%88%BF%E5%B1%8B%E5%9D%90%E5%90%91%E6%80%8E%E4%B9%88%E7%9C%8B/">房屋坐向以什么为准 房屋坐向怎么看</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/12/453-FME%20Desktop%202021%20for%20Mac%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91%E6%95%99%E7%A8%8B/">FME Desktop 2021 for Mac安装踩坑教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/29/452-%E4%BF%9D%E5%8F%B7google%20voice%E9%99%84%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE/">保号google voice附使用建议</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/14/451-5G%20Wifi%20Router%20Band%20Channel%20limit%E4%BF%AE%E6%94%B95GWIFI%E8%B7%AF%E7%94%B1%E4%B8%AD%E5%9B%BD%E9%A2%91%E6%AE%B5%E9%99%90%E5%88%B6/">5G Wifi Router Band Channel limit修改5GWIFI路由中国频段限制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/450-%E8%80%81%E6%AC%BEiPhone%E5%8F%98%E6%85%A2%E5%8D%A1%E9%A1%BF%E6%8E%89%E5%B8%A7%E5%8F%91%E7%83%AD%E5%88%87%E6%8D%A2%E8%BF%9F%E7%BC%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/">老款iPhone变慢卡顿掉帧发热切换迟缓解决方法分享</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/13/449-python%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E5%81%8F%E6%96%B9/">python中文字符乱码解决偏方</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/06/02/448-Python%20opencv%20error%20215%20imshow%20%E9%97%AE%E9%A2%98/">Python opencv error 215 imshow 问题</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">From to Earth.</a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
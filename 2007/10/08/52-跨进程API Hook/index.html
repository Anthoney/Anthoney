<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>跨进程API Hook | from2.net</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">跨进程API Hook</h1><a id="logo" href="/.">from2.net</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">跨进程API Hook</h1><div class="post-meta">2007-10-08<span> | </span><span class="category"><a href="/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/">软件技术</a></span></div><div class="post-content"><p>跨进程API&nbsp;Hook（初稿）<br /><br />什么是&ldquo;跨进程&nbsp;API&nbsp;Hook&rdquo;？<br /></p>
<div class="left_6_1" id="w_hzh">&nbsp;</div>
众所周知<a href="http://www.qqread.com/keys/windows/index.html" target="_blank">Windows</a>应用程序的各种系统功能是通过调用API函数来实现。API&nbsp;Hook就是给系统的API附加上一段小程序，它能监视甚至控制应用程序对API函数的调用。所谓跨进程也就是让自己的程序来控制别人程序的API调用了。<br /><br />API&nbsp;Hook&nbsp;理论<br />通过对Win32&nbsp;PE文件的分析(如果你还不熟悉PE文件格式，可以看看Iczelion的PE教程或者LUEVELSMEYER的&lt;&gt;)。我们知道在PE文件中的IMPORT&nbsp;TABLE内存储着API函数的很多信息。其中包括API的函数名，调用地址等等。而操作系统在执行PE文件时会先将其映射到内存中。在映射的同时还会把当前版本操作系统中API函数的入口地址写入IMPORT&nbsp;TABLE中一组与API调用相关的结构体内，用于该应用程序的API调用。&nbsp;当应用程序调用API时，他会在自己内存映像里寻找API的入口地址，然后执行CALL指令。如此一来，我们通过修改应用程序内存映像的IMPORT&nbsp;TABLE中API函数的入口地址，就可以达到重定向API的目的。将API地址改为我们自己函数的地址，这样我们的函数就可以完成对API的监视和控制了。<br /><br />API&nbsp;Hook&nbsp;的实现<br />/*&nbsp;1&nbsp;*/HANDLE&nbsp;hCurrent&nbsp;=&nbsp;GetModuleHandle(NULL);<br />/*&nbsp;2&nbsp;*/IMAGE_DOS_HEADER&nbsp;*pidh;<br />/*&nbsp;3&nbsp;*/IMAGE_NT_HEADERS&nbsp;*pinh;<br />/*&nbsp;4&nbsp;*/IMAGE_DATA_DIRECTORY&nbsp;*pSymbolTable;<br />/*&nbsp;5&nbsp;*/IMAGE_IMPORT_DESCRIPTOR&nbsp;*piid;<br />&nbsp;<br />/*&nbsp;6&nbsp;*/pidh&nbsp;=&nbsp;(IMAGE_DOS_HEADER&nbsp;*)hCurrent;&nbsp;<br />/*&nbsp;7&nbsp;*/pinh&nbsp;=&nbsp;(IMAGE_NT_HEADERS&nbsp;*)((DWORD)hCurrent&nbsp;+&nbsp;pidh-&gt;e_lfanew);<br />/*&nbsp;8&nbsp;*/pSymbolTable&nbsp;=&nbsp;&amp;pinh-&gt;OptionalHeader.DataDirectory[1];<br />/*&nbsp;9&nbsp;*/piid&nbsp;=(IMAGE_IMPORT_DESCRIPTOR&nbsp;*)((DWORD)hCurrent&nbsp;+&nbsp;&nbsp;pSymbolTable-&gt;VirtualAddress);<br />/*10&nbsp;*/do&nbsp;{<br />/*11&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_THUNK_DATA&nbsp;*pitd,*pitd2;<br />/*12&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;pitd&nbsp;=&nbsp;(IMAGE_THUNK_DATA&nbsp;*)((DWORD)hCurrent&nbsp;+&nbsp;piid-&gt;OriginalFirstThunk);<br />/*13&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;pitd2&nbsp;=&nbsp;(IMAGE_THUNK_DATA&nbsp;*)((DWORD)hCurrent&nbsp;+&nbsp;piid-&gt;FirstThunk);<br />/*14&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{<br />/*15&nbsp;*/&nbsp;IMAGE_IMPORT_BY_NAME&nbsp;*piibn;<br />/*16&nbsp;*/&nbsp;piibn&nbsp;=&nbsp;(IMAGE_IMPORT_BY_NAME&nbsp;*)((DWORD)hCurrent&nbsp;+&nbsp;&nbsp;*((DWORD&nbsp;*)pitd));<br />/*17&nbsp;*/&nbsp;PROC&nbsp;*ppfn&nbsp;=&nbsp;(PROC&nbsp;*)(pitd2-&gt;u1.Function);<br />/*18&nbsp;*/&nbsp;if&nbsp;(!strcmp(&quot;MessageBoxW&quot;,(char&nbsp;*)piibn-&gt;Name))&nbsp;{<br />/*19&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldMsg&nbsp;=&nbsp;(MsgBoxType)(ppfn);<br />/*20&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;addr&nbsp;=&nbsp;(DWORD)MyMessage;<br />/*21&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;written&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;改变内存读写状态&nbsp;*/<br />/*22&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;oldAccess;<br />/*23&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VirtualProtect(&amp;pitd2-&gt;u1.Function,sizeof(DWORD),PAGE_WRITECOPY,&amp;oldAccess);<br />/*24&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APIAddress&nbsp;=&nbsp;(DWORD)&amp;pitd2-&gt;u1.Function;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;向内存映像写入数据&nbsp;*/<br />/*25&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteProcessMemory(GetCurrentProcess(),&amp;pitd2-&gt;u1.Function,&nbsp;&amp;addr,sizeof(DWORD),&nbsp;&amp;written);<br />/*26&nbsp;*/&nbsp;}<br />/*27&nbsp;*/&nbsp;pitd++;pitd2++;<br />/*28&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while&nbsp;(pitd-&gt;u1.Function);<br />&nbsp;<br />/*29&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;piid++;<br />/*30&nbsp;*/}&nbsp;while&nbsp;(piid-&gt;FirstThunk&nbsp;+&nbsp;piid-&gt;Characteristics&nbsp;<br />&nbsp;&nbsp;+&nbsp;piid-&gt;ForwarderChain&nbsp;+&nbsp;piid-&gt;Name&nbsp;+&nbsp;piid-&gt;TimeDateStamp);<br />分析:<br />寻觅IMPORT&nbsp;TALBE<br />在/*1*/中我们使用GetModuleHandle(NULL)来返回当前进程在内存中映像的基地址。但这个值在文档中仅仅被描述为&quot;a&nbsp;module&nbsp;handle&nbsp;for&nbsp;the&nbsp;specified&nbsp;module&quot;，虽然他确实是进程内存映像的基地址。如果你不太放心的话也可以使用，GetModuleInformation函数来获得基地址，只不过你要额外包含psapi.h和psapi.lib了(这个库在VC6里没有，所以我就没有用这个函数了)。在/*&nbsp;6&nbsp;*/里我们先找到IMAGE_DOS_HEADER结构，他的起始地址就是映像的基地址。/*7*/通过IMAGE_DOS_HEADER给出的PE文件头的偏移量，找到IMAGE_NT_HEADERS结构。顺藤摸瓜，IMAGE_NT_HEADERS里的OptionalHeader中的DataDirectory数组里的第二个元素正是指向我们想要的IMPORT&nbsp;TABLE的地址。在/*9*/中我们将其转化为一个IMAGE_IMPORT_DESCRIPTOR的结构指针存入piid中。<br /><br />替换的API函数入口地址<br />在/*12*/和/*13*/中我们分别取得OriginalFirstThunk和FirstThunk结构，用于以后得到API函数的名称和入口地址。/*10*/的do循环让我们遍历每一个IMAGE_IMPORT_DESCRIPTOR结构也就是应用程序引用的每个DLL。在/*14*/的循环中我们遍历DLL中的IMAGE_THUNK_DATA结构来一一查询API的信息。/*16*/中我们将OriginalFirstThunk转换为IMAGE_IMPORT_BY_NAME结构用于获得API函数的名称进行比对。在/*18*/我们找到MessageBoxW函数之后，在/*19*/保存其原始入口地址便于以后恢复时使用。在/*23*/我们需要用VirtualProtect改变一下内存区域的读写性，因为一般应用程序的映像都是只读的，直接写入会造成一个非法访问的异常出现。在/*25*/我们写入自己函数的地址。<br /><br />这样就基本完成一个API函数的重定向。<br /><br />其他<br />恢复函数的API入口地址相对比较简单。只要把保存的值再写回去就可以了。上面的程序中/*24*/我用APIAddress保存了存有MessageBoxW入口地址的地方的地址，便于以后调用WriteProcessMemory恢复时使用。<br /><br />跨进程理论<br />我们要用自己的函数来替代别人程序里的API函数，但我们的函数与别人的程序处于不同的进程空间内啊。不同的进程空间是不能相互调用函数的。因此我们要想办法把自己的函数放入别人的进程空间去。这时我们就需要使用DLL&nbsp;injection技术了。如果你对她还不是十分熟悉的话，建议看看Jeffrey&nbsp;Richter大师的&lt;&gt;，也可以参考陈宽达先生的&lt;&gt;。<br /><br />简而言之，DLL&nbsp;injection就是想办法让对方的进程加载我们的一个DLL程序，把需要替换的函数放在我们这个DLL里。如此一来，我们的函数就进入了别人的进程空间了。DLL&nbsp;injection方法很多，Richter大师在书中对各方法利弊有详细解释，陈宽大先生的书中也有深入的分析。我在这里使用SetWindowsHookEx函数来达到目的。主要有这几个原因:&nbsp;1,&nbsp;不用重新启动系统，调试方便。2,&nbsp;可以利用消息循环机制进行两个进程之间的<a href="http://www.qqread.com/z/telecom/hot/index.html" target="_blank">通信</a>，可以较好的掌握Hook的状态。便于安装与卸载。<br /><br />SetWindowsHookEx之所以能完成DLL&nbsp;injection是因为它要给一个应用程序某个环节加上一个Hook,而Hook就要有Hook&nbsp;Procedure也就是Hook函数。如果这个Hook函数在一个DLL中，那么系统就会把这个DLL加载到SetWindowsHookEx的目标进程上。从而也就达到了我们DLL&nbsp;injection的目的了。当然这里我们会用WH_GETMESSAGE的Hook进行injection,因为这个Hook可以用来监视目标进程的消息循环方便我们的进程与目标进程通信。&nbsp;<br /><br />跨进程的实现和几点注意<br />/*&nbsp;DllPart.Dll&nbsp;*/<br />#include&nbsp;<br />#include&nbsp;<br />#include&nbsp;<br />#include&nbsp;<br />typedef&nbsp;(WINAPI&nbsp;*MsgBoxType)(HWND,LPCWSTR,LPCWSTR,UINT);&nbsp;<br />MsgBoxType&nbsp;oldMsg;&nbsp;&nbsp;/*API原入口地址*/<br />DWORD&nbsp;APIAddress;&nbsp;/*存储API入口地址的地方的地址*/<br />int&nbsp;WINAPI&nbsp;&nbsp;MyMessage(HWND&nbsp;hWnd&nbsp;,LPCWSTR&nbsp;M1,LPCWSTR&nbsp;M2,&nbsp;UINT&nbsp;M3)&nbsp;{<br />&nbsp;/*&nbsp;这是用来替换的函数&nbsp;*/<br />&nbsp;return&nbsp;oldMsg(hWnd,buf,M2,MB_OK);<br />}<br />const&nbsp;char&nbsp;szApp[]&nbsp;=&nbsp;&quot;DllPart.dll&quot;;<br />HHOOK&nbsp;hHook;&nbsp;/*Hook的句柄*/<br />HMODULE&nbsp;hInst;&nbsp;/*DLL&nbsp;模块句柄，用于SetWindowsHookEx函数*/<br />HWND&nbsp;hTarget;&nbsp;/*目标窗口句柄*/<br />/*DLL&nbsp;入口*/<br />BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;inst,&nbsp;DWORD&nbsp;reason,&nbsp;LPVOID&nbsp;lpvReserved)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;hInst&nbsp;=&nbsp;inst;<br />&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(reason)&nbsp;{<br />&nbsp;case&nbsp;DLL_PROCESS_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*调试信息，表示DLL已经加载*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(NULL,&quot;DLL_PROCESS_ATTACH&quot;,szApp,MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;case&nbsp;DLL_PROCESS_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*调试信息，表示DLL已经卸载*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(NULL,&quot;DLL_PROCESS_DETACH&quot;,szApp,MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br />}<br />/*显示GetLastError的信息*/<br />void&nbsp;showerr(const&nbsp;char&nbsp;*m)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;message[255];<br />&nbsp;&nbsp;&nbsp;&nbsp;FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,0,GetLastError()<br />&nbsp;,MAKELANGID(LANG_NEUTRAL,&nbsp;SUBLANG_DEFAULT),message,255,&nbsp;0);<br />&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(NULL,message,m,MB_OK);<br />}<br />//-----------------------<br />void&nbsp;UnHookApi()&nbsp;{<br />&nbsp;/*卸载API&nbsp;Hook用*/<br />}<br />void&nbsp;HookApi()&nbsp;{<br />&nbsp;/*加载API&nbsp;Hook同上面介绍的函数一样*/<br />}<br />//-----------------------<br />/*用于WH_GETMESSAGE的Hook&nbsp;Procedure*/<br />LRESULT&nbsp;CALLBACK&nbsp;GetMsgProc(int&nbsp;nCode,WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam)&nbsp;{<br />&nbsp;if&nbsp;(nCode&nbsp;==&nbsp;HC_ACTION)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG&nbsp;*msg&nbsp;=&nbsp;(MSG&nbsp;*)lParam;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(msg-&gt;message&nbsp;==&nbsp;WM_CHAR)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(msg-&gt;wParam&nbsp;==&nbsp;'h')&nbsp;HookApi();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(msg-&gt;wParam&nbsp;==&nbsp;'u')&nbsp;UnHookApi();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CallNextHookEx(hHook,nCode,wParam,lParam);<br />}<br />extern&nbsp;&quot;C&quot;&nbsp;__declspec(dllexport)&nbsp;SetAPIHook(HWND&nbsp;handle)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;ThreadId&nbsp;=&nbsp;GetWindowThreadProcessId(handle,&nbsp;NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;hTarget&nbsp;=&nbsp;handle;<br />&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(NULL,&nbsp;&quot;Enabling&nbsp;CallWndProc&nbsp;Hook&quot;,&nbsp;szApp,&nbsp;MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;hHook&nbsp;=&nbsp;SetWindowsHookEx(WH_GETMESSAGE,GetMsgProc,hInst,ThreadId);&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hHook)&nbsp;{<br />&nbsp;MessageBox(NULL,&quot;Hook&nbsp;OK!&quot;,&nbsp;szApp,&nbsp;MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;showerr(&quot;SetWindowsHookEx&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />extern&nbsp;&quot;C&quot;&nbsp;__declspec(dllexport)&nbsp;UnHookAPIHook()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(NULL,&nbsp;&quot;Disenabling&nbsp;CallWndProc&nbsp;Hook&quot;,&nbsp;szApp,&nbsp;MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(UnhookWindowsHookEx(hHook))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(NULL,&quot;UnHook&nbsp;OK!&quot;,&nbsp;szApp,&nbsp;MB_OK);&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;showerr(&quot;UnHookWindowsHookEx&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />分析<br />几个需要注意的问题<br />SetAPIHook和UnHookAPIHook是我们自己进程调用的用来加载WH_GETMESSAGE&nbsp;Hook的函数。由于我们的程序要用LoadLibrary加载这个Dll因此这两个函数要用__declspec(dllexport)修饰，使其成为导出函数，才能被GetAddressProc函数找到。加上&nbsp;extern&nbsp;&quot;C&quot;是让编译器使用<a href="http://www.qqread.com/keys/c-language/index.html" target="_blank">C语言</a>编码方式。因为C++编译器会进行Dynamic&nbsp;Binding(C++函数重载的实现),将函数的参数类型附加到名称上。是函数的导出名看起来像SetAPIHook@XYTZX之类的,不利于GetAddressProc进行引用。因此使用extern&nbsp;&quot;C&quot;让编译器不使用Dynamic&nbsp;Binding，自然使用extern&quot;C&quot;的函数也就不能被重载了。<br /><br />不要忘记在GetMsgProc最后要调用CallNextHookEx函数，保证Hook链的完整性。<br /><br />一定要在Hook&nbsp;Procedure中调用HookApi和UnHookApi函数，因为保存API入口地址的地方在目标进程中，你必须在目标进程的进程空间内完成卸载操作，不能在UnHookAPIHook或是SetAPIHook函数中调用，因为UnHookAPIHook是我们的进程调用的，因此在我们的进程空间中。在这里使用UnHookApi会造成一个非法访问的错误。而使用HookApi会给自己的DLL加上API&nbsp;Hook。<br /><br />SetWindowsHookEx的最后参数是ThreadId不是Handle,因此要通过调用GetWindowThreadProcessId转换一下。&nbsp;<br /><br />在跨进程API&nbsp;HOOK时可能用到的其他技术<br />主进程与目标进程的信息交互和共享<br />由于使用了WH_GETMESSAGE钩子我们可以利用Windows消息机制实现进程间通讯。需要注意的是应该使用PostThreadMessage来发送让WH_GETMESSAGE得到的消息而不是SendMessage或者PostMessage,因为后两个是用来给窗口发送消息的。而我们的WH_GETMESSAGE是Hook在线程上面的，因此需使用PostThreadMessage.<br /><br />传递不太大的数据可以使用WM_COPYDATA消息来进行。同样也应该注意，如果使用<a href="http://www.qqread.com/keys/mfc/index.html" target="_blank">MFC</a>的窗口过程获得消息就需要用SendMessage发送了。WM_COPYDATA的使用相对简单可以参考MSDN的文档。也可以参考附录里的程序Hook.cpp的showerr函数部分。<br /><br />如果传递较大的数据或者希望数据共享比较方便可以开辟共享内存来进行数据共享。这里简单分析一下使用共享内存的代码&nbsp;<br /><br />HANDLE&nbsp;hMap;<br />switch&nbsp;(reason)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;/*创建/打开共享内存区域*/<br />&nbsp;&nbsp;&nbsp;&nbsp;hMap&nbsp;=&nbsp;CreateFileMapping((HFILE&nbsp;*)0xFFFFFFFF,NULL,PAGE_READWRITE,0,sizeof(GLOBALDATA),ID_MAP);<br />&nbsp;&nbsp;&nbsp;&nbsp;pg_data&nbsp;=&nbsp;(GLOBALDATA*)MapViewOfFile(hMap,FILE_MAP_ALL_ACCESS,0&nbsp;,0&nbsp;,0);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pg_data)&nbsp;{<br />&nbsp;MessageBox(NULL,&quot;无法建立共享内存，程序终止！&quot;,szApp,MB_OK);<br />&nbsp;if&nbsp;(hMap)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hMap);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hMap&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;hInst&nbsp;=&nbsp;hInst;<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;共享内存映像文件&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;DLL装载中...&quot;,FALSE);<br />&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pg_data)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnmapViewOfFile(pg_data);<br />&nbsp;pg_data&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hMap)&nbsp;{<br />&nbsp;CloseHandle(hMap);<br />&nbsp;hMap&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;break;<br />}<br /><br />上面的代码通过CreateFileMapping建立共享区域。将其第一个参数设置为0xFFFFFFFF使其能创建一个内存共享区域而不是文件。并标记为可读写的(PAGE_READWRITE).其大小为我们定义的结构体GLOBALDATA的大小。最后的ID_MAP是一个用来标示这个区域的字符串。打开或者创建完共享区域后，我们用MapViewOfFile来获得这个区域的地址。之后就可以直接使用pg_data来操作共享区域了。不要忘记在DLL退出的时候<a href="http://www.qqread.com/security/index.html" target="_blank">安全</a>的删除共享区域释放内存。&nbsp;<br />消息等待与安全卸载<br />在我们卸载WH_GETMESSAGE钩子之前必须先把目标程序的API调用恢复正常。我们不能再调用UnHookApi之后就立刻调用UnhookWindowsHookEx,因为很有可能UnHookApi还没来得急完成API入口地址的恢复操作，WH_GETMESSAGE钩子就已经被卸载了。因此需要等待一段时间，等UnHookApi完成了恢复操作在调用UnhookWindowsHookEx。以防错误发生。<br /><br />extern&nbsp;&quot;C&quot;&nbsp;__declspec(dllexport)&nbsp;void&nbsp;UnHookAPIHook()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;/*向目标线程发送消息进行API&nbsp;UNHOOK*/<br />&nbsp;&nbsp;&nbsp;&nbsp;PostThreadMessage(pg_data-&gt;idTarget,WM_DISABLEAPIHOOK,(WPARAM)GetCurrentThreadId(),0);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;WM_DISABLEAPIHOOK&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;/*等待目标进程返回WM_UNHOOKOK消息，确认可以将WH_GETMESSAGE的HOOK去掉*/<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;MSG&nbsp;Msg;<br />&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetMessage(&amp;Msg,NULL,0,0);<br />&nbsp;&nbsp;&nbsp;&nbsp;}while(Msg.message&nbsp;!=&nbsp;&nbsp;WM_UNHOOKOK);<br />&nbsp;&nbsp;&nbsp;&nbsp;UnhookWindowsHookEx(pg_data-&gt;hHook);<br />&nbsp;&nbsp;&nbsp;&nbsp;PostThreadMessage(pg_data-&gt;idTarget,WM_DISABLEAPIHOOKOK,(WPARAM)GetCurrentThreadId(),0);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;UnHookWindowsHookEx&quot;);<br />}<br />上面的代码中我们使用一个含有GetMessage的循环来等待消息的到达，一旦UnHookApi完成他就会发送WM_UNHOOKOK消息。等我们接收到消息确认一切安全了在来卸载WH_GETMESSAGE钩子。&nbsp;<br />弄清消息对象<br />我们一定要清楚代码是在主程序进程空间中执行的还是在目标程序进程空间中执行的。像上面的UnHookAPIHook函数就是通过主程序调用的，因此在主程序进程空间中执行。这样一来用来恢复目标程序API信息的UnHookApi完成后就应该向主程序发送消息，而不是目标程序。<br /><br />目标进程加载了其他DLL<br />如果目标进程动态加载了其他的DLL文件，我们必须监视LoadLibrary函数。保证DLL中的API入口地址也被正确修改。防止出现混乱的情况。我从LoadLibrary获得DLL的路径用于GetModuleHandle来取得他的ImageBase的地址。<br /><br />不知道文章写的如何，希望大家能多给些批评意见。发现问题我马上改正<br />Email:&nbsp;detrox@yang.com.cn<br /><br />参考资料<br />&lt;&gt;,&nbsp;Jeffrey&nbsp;Richter,&nbsp;Microsoft&nbsp;Press<br /><br />&lt;&gt;,陈宽达,华中科大出版社<br /><br />&lt;&gt;,&nbsp;LUEVELSMEYER<br /><br />&lt;&gt;,&nbsp;Iczelion<br /><br />附:跨进程APIHook的例子<br />先打开一个记事本程序并输入几个字符，运行下面的程序，加载APIHook.之后在记事本的文件菜单中选择新建就会看到API&nbsp;Hook将MessageBoxW&nbsp;函数Hook的结果了.<br />代码在WinXP&nbsp;SP1&nbsp;+&nbsp;VC6.0测试成功。<br /><br />下载源代码<br /><br />(特别感谢老罗的代码着色器，比我自己那个好多了)<br /><br />这是DLL的程序，Hook.dll<br />#include&nbsp;<br />#include&nbsp;<br />#include&nbsp;<br />#include&nbsp;<br />#include&nbsp;&quot;mydef.h&quot;<br /><br />const&nbsp;char&nbsp;szApp[]&nbsp;=&nbsp;&quot;Hook.dll&quot;;&nbsp;/*应用程序名称*/<br />HANDLE&nbsp;hMap;/*在共享内存映像的句柄*/<br />GLOBALDATA&nbsp;*pg_data;&nbsp;/*在共享内存中的全局数据*/<br />LRESULT&nbsp;CALLBACK&nbsp;GetMsgProc(int,WPARAM,&nbsp;LPARAM);<br /><br />/*显示GetLastError指出的错误*/<br />void&nbsp;showerr(const&nbsp;char&nbsp;*m,&nbsp;BOOL&nbsp;GetError&nbsp;=&nbsp;TRUE)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;message[127];<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[255];<br />&nbsp;&nbsp;&nbsp;&nbsp;COPYDATASTRUCT&nbsp;cds;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GetError)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,0<br />&nbsp;&nbsp;,GetLastError(),MAKELANGID(LANG_NEUTRAL,&nbsp;SUBLANG_DEFAULT),message,127,&nbsp;0);<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*message&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GetCurrentThreadId()&nbsp;!=&nbsp;pg_data-&gt;idMain)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(buf,&quot;目标程序空间DLL:&nbsp;%-30s&nbsp;[%-40s]&quot;,m,&nbsp;message);<br />&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(buf,&quot;主程序空间DLL&nbsp;&nbsp;:&nbsp;%-30s&nbsp;[%-40s]&quot;,m,&nbsp;message);<br />&nbsp;&nbsp;&nbsp;&nbsp;cds.lpData&nbsp;=&nbsp;buf;<br />&nbsp;&nbsp;&nbsp;&nbsp;cds.cbData&nbsp;=&nbsp;sizeof(buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;cds.dwData&nbsp;=&nbsp;0;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;SendMessage(pg_data-&gt;hWndMain,WM_COPYDATA,(WPARAM)pg_data-&gt;hWndTarget,(LPARAM)&amp;cds);<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;SetLastError(0);<br />}<br />int&nbsp;WINAPI&nbsp;MyMessageBoxW(HWND&nbsp;hWnd&nbsp;,LPCWSTR&nbsp;M1,LPCWSTR&nbsp;M2,&nbsp;UINT&nbsp;M3)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;wchar_t&nbsp;buf[255];<br />&nbsp;&nbsp;&nbsp;&nbsp;swprintf(buf,L&quot;!!这个窗口的API被Hook了!! HWND:&nbsp;0x%08X Message:&nbsp;%s Caption:&nbsp;%s&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,(DWORD&nbsp;*)hWnd<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;M1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;M2);<br />&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;oldAPIFunction(hWnd,buf,M2,MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pg_data-&gt;oldAPIFunction(hWnd,M1,M2,M3);<br />}<br /><br />/*DLL&nbsp;入口函数*/<br />BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;hInst,&nbsp;DWORD&nbsp;reason,LPVOID&nbsp;lpvReserved)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(reason)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*创建/打开共享内存区域*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hMap&nbsp;=&nbsp;CreateFileMapping((HFILE&nbsp;*)0xFFFFFFFF,NULL,PAGE_READWRITE,0,sizeof(GLOBALDATA),ID_MAP);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pg_data&nbsp;=&nbsp;(GLOBALDATA*)MapViewOfFile(hMap,FILE_MAP_ALL_ACCESS,0&nbsp;,0&nbsp;,0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pg_data)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(NULL,&quot;无法建立共享内存，程序终止！&quot;,szApp,MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hMap)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hMap);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hMap&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;hInst&nbsp;=&nbsp;hInst;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;共享内存映像文件&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;DLL装载中...&quot;,FALSE);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;DLL卸载中...&quot;,FALSE);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pg_data)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnmapViewOfFile(pg_data);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pg_data&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hMap)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hMap);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hMap&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br />}<br />/*卸载API&nbsp;Hook*/<br />void&nbsp;UnHookApi()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;written&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;oldaddrAPIFunction&nbsp;=&nbsp;(DWORD)pg_data-&gt;oldAPIFunction;<br />&nbsp;&nbsp;&nbsp;&nbsp;WriteProcessMemory(GetCurrentProcess(),(DWORD&nbsp;*)pg_data-&gt;addrAPIEntryPoint<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&amp;oldaddrAPIFunction,sizeof(DWORD),&nbsp;&amp;written);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;WriteProcessMemory&nbsp;on&nbsp;UnHook&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;/*向主线程发送&nbsp;API&nbsp;UNHOOK&nbsp;处理完毕的消息*/<br />&nbsp;&nbsp;&nbsp;&nbsp;PostThreadMessage(pg_data-&gt;idMain,WM_UNHOOKOK,0,0);<br />}<br /><br />/*加载API&nbsp;Hook*/<br />void&nbsp;HookApi(const&nbsp;char*&nbsp;szApiName,&nbsp;tAPIFunction&nbsp;newAddr,&nbsp;DWORD&nbsp;ImageBase)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;/*这段代码请参考文章中的分析*/<br />&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_DOS_HEADER&nbsp;*pidh;<br />&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_NT_HEADERS&nbsp;*pinh;<br />&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_DATA_DIRECTORY&nbsp;*pSymbolTable;<br />&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_IMPORT_DESCRIPTOR&nbsp;*piid;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;pidh&nbsp;=&nbsp;(IMAGE_DOS_HEADER&nbsp;*)ImageBase;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;pinh&nbsp;=&nbsp;(IMAGE_NT_HEADERS&nbsp;*)((DWORD)ImageBase&nbsp;+&nbsp;pidh-&gt;e_lfanew);<br />&nbsp;&nbsp;&nbsp;&nbsp;pSymbolTable&nbsp;=&nbsp;&amp;pinh-&gt;OptionalHeader.DataDirectory[1];<br />&nbsp;&nbsp;&nbsp;&nbsp;piid&nbsp;=(IMAGE_IMPORT_DESCRIPTOR&nbsp;*)((DWORD)ImageBase&nbsp;+&nbsp;&nbsp;pSymbolTable-&gt;VirtualAddress);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_THUNK_DATA&nbsp;*pitd_org,*pitd_1st;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pitd_org&nbsp;=&nbsp;(IMAGE_THUNK_DATA&nbsp;*)((DWORD)ImageBase&nbsp;+&nbsp;piid-&gt;OriginalFirstThunk);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pitd_1st&nbsp;=&nbsp;(IMAGE_THUNK_DATA&nbsp;*)((DWORD)ImageBase&nbsp;+&nbsp;piid-&gt;FirstThunk);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_IMPORT_BY_NAME&nbsp;*piibn;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;piibn&nbsp;=&nbsp;(IMAGE_IMPORT_BY_NAME&nbsp;*)((DWORD)ImageBase&nbsp;+&nbsp;&nbsp;*((DWORD&nbsp;*)pitd_org));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROC&nbsp;*pAPIFunction&nbsp;=&nbsp;(PROC&nbsp;*)(pitd_1st-&gt;u1.Function);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!strcmp(szApiName,(char&nbsp;*)piibn-&gt;Name))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;addrNewAPIFunction&nbsp;=&nbsp;(DWORD)MyMessageBoxW;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;written&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;oldAccess;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;oldAPIFunction&nbsp;=&nbsp;(tAPIFunction)(pAPIFunction);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Change&nbsp;Memeory&nbsp;State*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VirtualProtect(&amp;pitd_1st-&gt;u1.Function,sizeof(DWORD),PAGE_WRITECOPY,&amp;oldAccess);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;VirtualProtect&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;addrAPIEntryPoint&nbsp;=&nbsp;(DWORD)&amp;pitd_1st-&gt;u1.Function;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Write&nbsp;Process&nbsp;Memory*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteProcessMemory(GetCurrentProcess(),&amp;pitd_1st-&gt;u1.Function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&amp;addrNewAPIFunction,sizeof(DWORD),&nbsp;&amp;written);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;WriteProcessMemory&nbsp;on&nbsp;Hook&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pitd_org++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pitd_1st++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while&nbsp;(pitd_1st-&gt;u1.Function);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;piid++;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while&nbsp;(piid-&gt;FirstThunk&nbsp;+&nbsp;piid-&gt;Characteristics&nbsp;<br />&nbsp;+&nbsp;piid-&gt;ForwarderChain&nbsp;+&nbsp;piid-&gt;Name&nbsp;+&nbsp;piid-&gt;TimeDateStamp);<br />}<br /><br />//-----------------------<br />extern&nbsp;&quot;C&quot;&nbsp;__declspec(dllexport)&nbsp;BOOL&nbsp;SetAPIHook(HWND&nbsp;_target)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;hHook&nbsp;=&nbsp;SetWindowsHookEx(WH_GETMESSAGE,GetMsgProc,pg_data-&gt;hInst,pg_data-&gt;idTarget);&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;SetWindowsHookEx&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;/*向目标线程发送消息进行API&nbsp;HOOK*/<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pg_data-&gt;hHook)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PostThreadMessage(pg_data-&gt;idTarget,WM_ENABLEAPIHOOK,0,0);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;WM_ENABLEAPIHOOK&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;__declspec(dllexport)&nbsp;void&nbsp;UnHookAPIHook()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;/*向目标线程发送消息进行API&nbsp;UNHOOK*/<br />&nbsp;&nbsp;&nbsp;&nbsp;PostThreadMessage(pg_data-&gt;idTarget,WM_DISABLEAPIHOOK,(WPARAM)GetCurrentThreadId(),0);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;WM_DISABLEAPIHOOK&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;/*等待目标进程返回WM_UNHOOKOK消息，确认可以将WH_GETMESSAGE的HOOK去掉*/<br />&nbsp;&nbsp;&nbsp;&nbsp;MSG&nbsp;Msg;<br />&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetMessage(&amp;Msg,NULL,0,0);<br />&nbsp;&nbsp;&nbsp;&nbsp;}while(Msg.message&nbsp;!=&nbsp;&nbsp;WM_UNHOOKOK);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;UnhookWindowsHookEx(pg_data-&gt;hHook);<br />&nbsp;&nbsp;&nbsp;&nbsp;PostThreadMessage(pg_data-&gt;idTarget,WM_DISABLEAPIHOOKOK,(WPARAM)GetCurrentThreadId(),0);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;UnHookWindowsHookEx&quot;);<br />}<br /><br />LRESULT&nbsp;CALLBACK&nbsp;GetMsgProc(int&nbsp;nCode,WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nCode&nbsp;==&nbsp;HC_ACTION)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSG&nbsp;*msg&nbsp;=&nbsp;(MSG&nbsp;*)lParam;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(msg-&gt;message&nbsp;==&nbsp;WM_ENABLEAPIHOOK)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HookApi(&quot;MessageBoxW&quot;,MyMessageBoxW,(DWORD)GetModuleHandle(NULL));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(msg-&gt;message&nbsp;==&nbsp;WM_DISABLEAPIHOOK)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnHookApi();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(msg-&gt;message&nbsp;==&nbsp;WM_DESTROY)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;目标进程退出!&quot;,FALSE);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CallNextHookEx(pg_data-&gt;hHook,nCode,wParam,lParam);<br />}<br />　<br />这个是主程序的关键部分&nbsp;HookGui.cpp<br />用MFC建立一个窗口程序，包含两个按钮和一个ListBox<br /><br />typedef&nbsp;void&nbsp;(*PUnHookAPIHook)();<br />typedef&nbsp;BOOL&nbsp;(*PSetAPIHook)(HWND);<br />HMODULE&nbsp;hDll&nbsp;=&nbsp;NULL;<br />HWND&nbsp;hNotePad&nbsp;=&nbsp;NULL;<br />PSetAPIHook&nbsp;SetAPIHook;<br />PUnHookAPIHook&nbsp;UnHookAPIHook;<br />GLOBALDATA&nbsp;*pg_data;&nbsp;/*在共享内存中的全局数据*/<br />HANDLE&nbsp;hMap;&nbsp;/*在共享内存映像的句柄*/<br />int&nbsp;CHookGUIDlg::showerr(const&nbsp;char*&nbsp;m)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;message[127];<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[255];<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;errId&nbsp;=&nbsp;GetLastError();<br />&nbsp;&nbsp;&nbsp;&nbsp;FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,0<br />&nbsp;,errId,MAKELANGID(LANG_NEUTRAL,&nbsp;SUBLANG_DEFAULT),message,127,&nbsp;0);<br />&nbsp;&nbsp;&nbsp;&nbsp;sprintf(buf,&quot;主程序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;%-30s&nbsp;[%-40s] &quot;,m,&nbsp;message);<br />&nbsp;&nbsp;&nbsp;&nbsp;c_List1.InsertString(c_List1.GetCount(),buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;UpdateData(FALSE);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;errId;<br />}<br /><br />void&nbsp;CHookGUIDlg::OnSetapihook()&nbsp;<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO:&nbsp;Add&nbsp;your&nbsp;control&nbsp;notification&nbsp;handler&nbsp;code&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;hDll&nbsp;=&nbsp;LoadLibrary(&quot;Hook.dll&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;LoadLibrary&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;hMap&nbsp;=&nbsp;OpenFileMapping(FILE_MAP_ALL_ACCESS,false,ID_MAP);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;OpenFileMapping&quot;);&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;pg_data&nbsp;=&nbsp;(GLOBALDATA&nbsp;*)MapViewOfFile(hMap,FILE_MAP_ALL_ACCESS,0,0,0);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;MapViewOfFile&quot;);&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pg_data)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(&quot;不能打开共享内存程序终止!&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;SetAPIHook&nbsp;=&nbsp;(PSetAPIHook)GetProcAddress(hDll,&quot;SetAPIHook&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;GetProcAddress-SetAPIHOOK&quot;);<br />&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;hWndTarget&nbsp;=&nbsp;::FindWindow(&quot;NotePad&quot;,NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;hWndMain&nbsp;=&nbsp;m_hWnd;<br />&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;idMain&nbsp;=&nbsp;GetWindowThreadProcessId(m_hWnd,NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;pg_data-&gt;idTarget&nbsp;=&nbsp;GetWindowThreadProcessId(pg_data-&gt;hWndTarget,NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!showerr(&quot;FindWindow&quot;))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(SetAPIHook)&nbsp;{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(SetAPIHook(hNotePad))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PostThreadMessage(pg_data-&gt;idTarget<br />&nbsp;&nbsp;&nbsp;,&nbsp;WM_SETCALLERID,(LPARAM)GetCurrentThreadId(),0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(&quot;SetWindowHookEx时出错，程序终止！&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(&quot;无法取得SetAPIHook函数！程序终止！&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(&quot;内存中没有找到NOTEPAD.EXE&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;c_SetApiHook.EnableWindow(FALSE);<br />&nbsp;&nbsp;&nbsp;&nbsp;c_UnsetApiHook.EnableWindow();<br />}<br /><br />void&nbsp;CHookGUIDlg::OnUnsetapihook()&nbsp;<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO:&nbsp;Add&nbsp;your&nbsp;control&nbsp;notification&nbsp;handler&nbsp;code&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hDll)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!IsWindow(pg_data-&gt;hWndTarget))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(&quot;目标进程不在内存中&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnHookAPIHook&nbsp;=&nbsp;(PUnHookAPIHook)GetProcAddress(hDll,&quot;UnHookAPIHook&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;GetProcAddress-UnHookAPIHook&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(UnHookAPIHook)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnHookAPIHook();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FreeLibrary(hDll);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showerr(&quot;FreeLibrary&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hDll&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox(&quot;请先加载DLL&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;c_SetApiHook.EnableWindow();<br />&nbsp;&nbsp;&nbsp;&nbsp;c_UnsetApiHook.EnableWindow(FALSE);<br />}<br /><br />void&nbsp;CHookGUIDlg::OnOK()&nbsp;<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO:&nbsp;Add&nbsp;extra&nbsp;validation&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hDll)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OnUnsetapihook();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;CDialog::OnOK();<br />}<br /><br />BOOL&nbsp;CHookGUIDlg::OnCopyData(CWnd*&nbsp;pWnd,&nbsp;COPYDATASTRUCT*&nbsp;pCopyDataStruct)&nbsp;<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO:&nbsp;Add&nbsp;your&nbsp;message&nbsp;handler&nbsp;code&nbsp;here&nbsp;and/or&nbsp;call&nbsp;default<br />&nbsp;&nbsp;&nbsp;&nbsp;c_List1.InsertString(c_List1.GetCount(),(char&nbsp;*)pCopyDataStruct-&gt;lpData);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CDialog::OnCopyData(pWnd,&nbsp;pCopyDataStruct);<br /></div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2007/10/08/53-dll%E5%B8%B8%E8%AF%86/">dll常识</a><a class="next" href="/2007/10/08/51-%E6%B5%85%E8%B0%88%E6%98%BE%20ipqq%20%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%20%E9%99%84%E6%98%BE%20ipqq%E5%8E%9F%E7%90%86/">浅谈显 ipqq 发展历程 附显 ipqq原理</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://anthoney.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/yontaw" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@from2.net" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/anthoney" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GIS/">GIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E6%96%87%E5%9C%B0%E7%90%86/">人文地理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%83%E5%96%9D%E7%8E%A9%E4%B9%90/">吃喝玩乐</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%96%E8%AF%AD/">外语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%B1%E9%9F%B3%E5%9B%BE%E5%BD%A2/">影音图形</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E8%B7%AF/">心路</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/">软件技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A3%9E%E8%A1%8C%E6%A2%A6%E6%83%B3/">飞行梦想</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/09/30/455-FlexNet%20lmtools%20license%20vitual%20adapter%20Revit%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1/">FlexNet lmtools license vitual adapter Revit配置虚拟网卡</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/08/454-%E6%88%BF%E5%B1%8B%E5%9D%90%E5%90%91%E4%BB%A5%E4%BB%80%E4%B9%88%E4%B8%BA%E5%87%86%20%E6%88%BF%E5%B1%8B%E5%9D%90%E5%90%91%E6%80%8E%E4%B9%88%E7%9C%8B/">房屋坐向以什么为准 房屋坐向怎么看</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/12/453-FME%20Desktop%202021%20for%20Mac%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91%E6%95%99%E7%A8%8B/">FME Desktop 2021 for Mac安装踩坑教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/29/452-%E4%BF%9D%E5%8F%B7google%20voice%E9%99%84%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE/">保号google voice附使用建议</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/14/451-5G%20Wifi%20Router%20Band%20Channel%20limit%E4%BF%AE%E6%94%B95GWIFI%E8%B7%AF%E7%94%B1%E4%B8%AD%E5%9B%BD%E9%A2%91%E6%AE%B5%E9%99%90%E5%88%B6/">5G Wifi Router Band Channel limit修改5GWIFI路由中国频段限制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/450-%E8%80%81%E6%AC%BEiPhone%E5%8F%98%E6%85%A2%E5%8D%A1%E9%A1%BF%E6%8E%89%E5%B8%A7%E5%8F%91%E7%83%AD%E5%88%87%E6%8D%A2%E8%BF%9F%E7%BC%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/">老款iPhone变慢卡顿掉帧发热切换迟缓解决方法分享</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/13/449-python%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E5%81%8F%E6%96%B9/">python中文字符乱码解决偏方</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/06/02/448-Python%20opencv%20error%20215%20imshow%20%E9%97%AE%E9%A2%98/">Python opencv error 215 imshow 问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/04/04/447-python%20faild_install_package%20%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">python faild_install_package 报错解决办法</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/06/16/446-%E5%8F%A4%E5%85%B8%E8%AF%97%E8%AF%8D/">古典诗词</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">from2.net.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>